#!/usr/bin/env python3
"""
Analysis script for sd-bit GEANT4 simulation results

This script reads ROOT files generated by the GEANT4 simulation
and creates publication-quality plots for analysis.
"""

import numpy as np
import matplotlib.pyplot as plt
import argparse
from pathlib import Path

try:
    import uproot
    HAS_UPROOT = True
except ImportError:
    HAS_UPROOT = False
    print("Warning: uproot not available. Install with: pip install uproot")

def load_root_data(filename):
    """Load data from ROOT file using uproot."""
    if not HAS_UPROOT:
        raise ImportError("uproot is required to read ROOT files")
    
    with uproot.open(filename) as file:
        # Load histograms
        edep_hist = file["Edep"]
        flip_hist = file["Flips"]
        
        # Extract histogram data
        edep_values, edep_edges = edep_hist.to_numpy()
        flip_values, flip_edges = flip_hist.to_numpy()
        
        # Load ntuple if available
        ntuple_data = None
        if "SdBitEvents" in file:
            ntuple = file["SdBitEvents"]
            ntuple_data = {
                'EventID': ntuple["EventID"].array(),
                'EnergyDeposited': ntuple["EnergyDeposited"].array(),
                'FlipProbability': ntuple["FlipProbability"].array(),
                'StateFlip': ntuple["StateFlip"].array()
            }
    
    return {
        'edep_hist': (edep_values, edep_edges),
        'flip_hist': (flip_values, flip_edges),
        'ntuple': ntuple_data
    }

def plot_energy_spectrum(edep_values, edep_edges, save_path=None):
    """Plot energy deposition spectrum."""
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Calculate bin centers
    bin_centers = (edep_edges[:-1] + edep_edges[1:]) / 2
    
    # Plot histogram
    ax.step(bin_centers * 1e6, edep_values, where='mid', linewidth=2)
    ax.fill_between(bin_centers * 1e6, edep_values, alpha=0.3)
    
    ax.set_xlabel('Energy Deposition (eV)')
    ax.set_ylabel('Counts')
    ax.set_title('Energy Deposition Spectrum in sd-bit Core')
    ax.grid(True, alpha=0.3)
    ax.set_yscale('log')
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    else:
        plt.show()
    
    return fig

def plot_flip_statistics(flip_values, flip_edges, save_path=None):
    """Plot state flip statistics."""
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Calculate flip probabilities
    total_flips = np.sum(flip_values)
    if total_flips > 0:
        flip_0 = flip_values[0] / total_flips
        flip_1 = flip_values[1] / total_flips
    else:
        flip_0 = flip_1 = 0
    
    # Bar plot
    states = ['State 0', 'State 1']
    probabilities = [flip_0, flip_1]
    
    bars = ax.bar(states, probabilities, color=['lightblue', 'lightcoral'], alpha=0.7)
    
    # Add value labels on bars
    for bar, prob in zip(bars, probabilities):
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                f'{prob:.3f}', ha='center', va='bottom')
    
    ax.set_ylabel('Probability')
    ax.set_title('State Flip Distribution')
    ax.set_ylim(0, 1)
    ax.grid(True, alpha=0.3)
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    else:
        plt.show()
    
    return fig

def analyze_flip_probability(ntuple_data):
    """Analyze flip probability vs energy deposition."""
    if ntuple_data is None:
        print("No ntuple data available for detailed analysis")
        return None
    
    energy = ntuple_data['EnergyDeposited']
    flip_prob = ntuple_data['FlipProbability']
    
    # Create energy bins
    energy_bins = np.logspace(np.log10(np.min(energy[energy > 0])), 
                             np.log10(np.max(energy)), 50)
    
    # Calculate average flip probability in each bin
    bin_centers = []
    avg_flip_prob = []
    
    for i in range(len(energy_bins) - 1):
        mask = (energy >= energy_bins[i]) & (energy < energy_bins[i+1])
        if np.sum(mask) > 0:
            bin_centers.append(np.sqrt(energy_bins[i] * energy_bins[i+1]))
            avg_flip_prob.append(np.mean(flip_prob[mask]))
    
    return np.array(bin_centers), np.array(avg_flip_prob)

def plot_flip_probability_vs_energy(energy, flip_prob, save_path=None):
    """Plot flip probability vs energy deposition."""
    fig, ax = plt.subplots(figsize=(10, 6))
    
    ax.semilogx(energy * 1e6, flip_prob, 'o-', markersize=4, linewidth=2)
    
    ax.set_xlabel('Energy Deposition (eV)')
    ax.set_ylabel('Flip Probability')
    ax.set_title('State Flip Probability vs Energy Deposition')
    ax.grid(True, alpha=0.3)
    ax.set_ylim(0, 1)
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    else:
        plt.show()
    
    return fig

def main():
    """Main analysis function."""
    parser = argparse.ArgumentParser(description='Analyze sd-bit GEANT4 simulation results')
    parser.add_argument('input_file', help='ROOT file from GEANT4 simulation')
    parser.add_argument('--output-dir', default='plots', help='Output directory for plots')
    parser.add_argument('--format', default='png', choices=['png', 'pdf', 'svg'], 
                       help='Output format for plots')
    
    args = parser.parse_args()
    
    if not HAS_UPROOT:
        print("Error: uproot is required to analyze ROOT files")
        print("Install with: pip install uproot")
        return
    
    # Create output directory
    output_dir = Path(args.output_dir)
    output_dir.mkdir(exist_ok=True)
    
    # Load data
    print(f"Loading data from {args.input_file}...")
    try:
        data = load_root_data(args.input_file)
    except Exception as e:
        print(f"Error loading ROOT file: {e}")
        return
    
    # Generate plots
    print("Generating energy spectrum plot...")
    edep_values, edep_edges = data['edep_hist']
    plot_energy_spectrum(edep_values, edep_edges, 
                        output_dir / f'energy_spectrum.{args.format}')
    
    print("Generating flip statistics plot...")
    flip_values, flip_edges = data['flip_hist']
    plot_flip_statistics(flip_values, flip_edges,
                        output_dir / f'flip_statistics.{args.format}')
    
    # Detailed analysis if ntuple data is available
    if data['ntuple'] is not None:
        print("Generating flip probability analysis...")
        energy, flip_prob = analyze_flip_probability(data['ntuple'])
        if energy is not None:
            plot_flip_probability_vs_energy(energy, flip_prob,
                                           output_dir / f'flip_prob_vs_energy.{args.format}')
    
    print(f"Analysis complete. Plots saved to {output_dir}")

if __name__ == "__main__":
    main()